{
  "id": 19,
  "title": "Remove Nth Node From End of List",
  "list": ["neetcode150"],
  "category": "Linked List",
  "difficulty": "Medium",
  "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
  "constraints": [
    "The number of nodes in the list is sz",
    "1 <= sz <= 30",
    "0 <= Node.val <= 100",
    "1 <= n <= sz"
  ],
  "testCases": [
    {
      "input": {
        "head": [1, 2, 3, 4, 5],
        "n": 2
      },
      "output": [1, 2, 3, 5],
      "explanation": "We remove the 2nd node from the end (node with value 4)."
    },
    {
      "input": {
        "head": [1],
        "n": 1
      },
      "output": [],
      "explanation": "We remove the only node in the list."
    },
    {
      "input": {
        "head": [1, 2],
        "n": 1
      },
      "output": [1],
      "explanation": "We remove the last node (node with value 2)."
    },
    {
      "input": {
        "head": [1, 2],
        "n": 2
      },
      "output": [2],
      "explanation": "We remove the first node (node with value 1)."
    }
  ],
  "solution": {
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\ndef removeNthFromEnd(head, n):\n    # Use two pointers: fast and slow\n    # Fast pointer moves n steps ahead first\n    dummy = ListNode(0)\n    dummy.next = head\n    \n    fast = slow = dummy\n    \n    # Move fast pointer n steps ahead\n    for _ in range(n + 1):\n        fast = fast.next\n    \n    # Move both pointers until fast reaches the end\n    while fast:\n        fast = fast.next\n        slow = slow.next\n    \n    # Remove the nth node from end\n    slow.next = slow.next.next\n    \n    return dummy.next\n\n# Alternative approach using length calculation\ndef removeNthFromEndLength(head, n):\n    # Calculate the length of the list\n    length = 0\n    current = head\n    while current:\n        length += 1\n        current = current.next\n    \n    # If we need to remove the first node\n    if length == n:\n        return head.next\n    \n    # Find the node before the one to be removed\n    current = head\n    for _ in range(length - n - 1):\n        current = current.next\n    \n    # Remove the node\n    current.next = current.next.next\n    \n    return head\n\n# Alternative approach with single pass and counter\ndef removeNthFromEndCounter(head, n):\n    dummy = ListNode(0)\n    dummy.next = head\n    \n    current = dummy\n    count = 0\n    \n    # First pass: count total nodes\n    while current.next:\n        count += 1\n        current = current.next\n    \n    # Second pass: remove the nth node from end\n    current = dummy\n    for _ in range(count - n):\n        current = current.next\n    \n    current.next = current.next.next\n    \n    return dummy.next",
    "explanation": "Three approaches are shown:\n\n1. Two-pointer approach (recommended):\n   - Use a dummy node to handle edge cases\n   - Move fast pointer n+1 steps ahead of slow pointer\n   - When fast reaches the end, slow is at the node before the one to remove\n   - Time complexity: O(n) with single pass\n   - Space complexity: O(1)\n\n2. Length calculation approach:\n   - First pass: calculate the length of the list\n   - Second pass: find the node to remove\n   - Handle special case when removing the first node\n   - Time complexity: O(n) with two passes\n   - Space complexity: O(1)\n\n3. Counter approach:\n   - Similar to length calculation but uses a counter\n   - Two passes through the list\n   - Time complexity: O(n)\n   - Space complexity: O(1)\n\nKey insight: The two-pointer approach is most efficient as it requires only one pass through the list.\n\nExample with [1,2,3,4,5] and n=2:\n- Dummy → 1 → 2 → 3 → 4 → 5\n- Fast starts at 3, slow starts at dummy\n- When fast reaches end (null), slow is at 3\n- Remove node 4: 3.next = 5\n- Result: [1,2,3,5]\n\nThe two-pointer approach is the standard solution for this problem."
  }
}

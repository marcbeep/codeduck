{
  "id": 4,
  "title": "Median of Two Sorted Arrays",
  "list": ["neetcode150"],
  "category": "Binary Search",
  "difficulty": "Hard",
  "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).",
  "constraints": [
    "nums1.length == m",
    "nums2.length == n",
    "0 <= m <= 1000",
    "0 <= n <= 1000",
    "1 <= m + n <= 2000",
    "-106 <= nums1[i], nums2[i] <= 106"
  ],
  "testCases": [
    {
      "input": {
        "nums1": [1, 3],
        "nums2": [2]
      },
      "output": 2.0,
      "explanation": "merged array = [1,2,3] and median is 2."
    },
    {
      "input": {
        "nums1": [1, 2],
        "nums2": [3, 4]
      },
      "output": 2.5,
      "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
    },
    {
      "input": {
        "nums1": [0, 0],
        "nums2": [0, 0]
      },
      "output": 0.0,
      "explanation": "merged array = [0,0,0,0] and median is 0."
    }
  ],
  "solution": {
    "code": "def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:\n    # Ensure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    \n    while left <= right:\n        # Partition nums1\n        partition_x = (left + right) // 2\n        # Partition nums2\n        partition_y = (m + n + 1) // 2 - partition_x\n        \n        # Find the four elements around the partition\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == m else nums1[partition_x]\n        \n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == n else nums2[partition_y]\n        \n        # Check if partition is correct\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            # Partition is correct, find median\n            if (m + n) % 2 == 0:\n                # Even length: average of two middle elements\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                # Odd length: max of left partition\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            # Move partition_x left\n            right = partition_x - 1\n        else:\n            # Move partition_x right\n            left = partition_x + 1\n    \n    # This should never be reached\n    return 0.0",
    "explanation": "This solution uses binary search with O(log(min(m,n))) time complexity:\n1. We use binary search to find the correct partition of both arrays\n2. We ensure nums1 is the smaller array for efficiency\n3. We partition both arrays such that all elements on the left are <= all elements on the right\n4. We check if the partition is correct by comparing the boundary elements\n5. If partition is correct, we calculate the median based on total length\n6. If not, we adjust the partition and continue binary search\n\nKey insights:\n- The median divides the merged array into two equal halves\n- All elements in the left half must be <= all elements in the right half\n- We can find this partition using binary search on the smaller array\n- The partition in the larger array is determined by the total length\n- We compare boundary elements to check if partition is correct\n\nExample: nums1 = [1,3], nums2 = [2]\n- m = 2, n = 1, total = 3 (odd)\n- Binary search on partition_x: left = 0, right = 2\n- partition_x = 1, partition_y = (3+1)//2 - 1 = 1\n- max_left_x = 1, min_right_x = 3, max_left_y = 2, min_right_y = inf\n- Check: 1 <= inf and 2 <= 3 âœ“\n- Total length is odd, return max(1,2) = 2.0\n\nThe time complexity is O(log(min(m,n))) as we use binary search on the smaller array. The space complexity is O(1) as we only use constant extra space."
  }
}

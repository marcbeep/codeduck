{
  "id": 226,
  "title": "Invert Binary Tree",
  "list": ["blind75"],
  "category": "Tree",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Binary Tree"
  ],
  "difficulty": "Easy",
  "description": "Given the root of a binary tree, invert the tree, and return its root.\n\nTo invert a binary tree, swap every left node with its corresponding right node.",
  "constraints": [
    "The number of nodes in the tree is in the range [0, 100]",
    "-100 <= Node.val <= 100"
  ],
  "testCases": [
    {
      "input": {
        "root": [4, 2, 7, 1, 3, 6, 9]
      },
      "output": [4, 7, 2, 9, 6, 3, 1],
      "explanation": "The tree is inverted by swapping left and right children of each node."
    },
    {
      "input": {
        "root": [2, 1, 3]
      },
      "output": [2, 3, 1],
      "explanation": "Simple case with just root and two children."
    },
    {
      "input": {
        "root": []
      },
      "output": [],
      "explanation": "Empty tree remains empty."
    }
  ],
  "solution": {
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef invert_tree(root):\n    # Base case: if root is None, return None\n    if not root:\n        return None\n    \n    # Swap left and right children\n    root.left, root.right = root.right, root.left\n    \n    # Recursively invert left and right subtrees\n    invert_tree(root.left)\n    invert_tree(root.right)\n    \n    return root\n\n# Alternative iterative approach using BFS\ndef invert_tree_iterative(root):\n    if not root:\n        return None\n    \n    # Use a queue for BFS\n    queue = [root]\n    \n    while queue:\n        node = queue.pop(0)\n        \n        # Swap left and right children\n        node.left, node.right = node.right, node.left\n        \n        # Add children to queue if they exist\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    \n    return root",
    "explanation": "Two approaches are shown:\n\n1. Recursive approach (DFS):\n   - Base case: if root is None, return None\n   - Swap left and right children of current node\n   - Recursively invert left and right subtrees\n   - Time complexity: O(n) where n is the number of nodes\n   - Space complexity: O(h) where h is the height of the tree (due to recursion stack)\n\n2. Iterative approach (BFS):\n   - Use a queue to process nodes level by level\n   - For each node, swap its left and right children\n   - Add children to queue for processing\n   - Time complexity: O(n)\n   - Space complexity: O(w) where w is the maximum width of the tree\n\nBoth approaches achieve the same result, but the recursive approach is more elegant and typically preferred for tree problems."
  }
}

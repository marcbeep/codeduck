{
  "id": 42,
  "title": "Trapping Rain Water",
  "list": ["grind75"],
  "category": "Array",
  "topics": [
    "Array",
    "Two Pointers",
    "Dynamic Programming",
    "Stack",
    "Monotonic Stack"
  ],
  "difficulty": "Hard",
  "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
  "constraints": [
    "n == height.length",
    "1 <= n <= 2 * 104",
    "0 <= height[i] <= 105"
  ],
  "testCases": [
    {
      "input": {
        "height": [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
      },
      "output": 6,
      "explanation": "The elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped."
    },
    {
      "input": {
        "height": [4, 2, 0, 3, 2, 5]
      },
      "output": 9,
      "explanation": "The elevation map is represented by array [4,2,0,3,2,5]. In this case, 9 units of rain water (blue section) are being trapped."
    },
    {
      "input": {
        "height": [1, 0, 1]
      },
      "output": 1,
      "explanation": "The elevation map is represented by array [1,0,1]. In this case, 1 unit of rain water (blue section) is being trapped."
    }
  ],
  "solution": {
    "code": "def trap(height: list[int]) -> int:\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            # Water can be trapped on the left side\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            # Water can be trapped on the right side\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water",
    "explanation": "This solution uses the two-pointer approach:\n1. We use two pointers starting from the ends of the array\n2. We keep track of the maximum heights seen from left and right\n3. We move the pointer with the smaller height inward\n4. At each position, we can trap water if the current height is less than the maximum height from that side\n5. The amount of water trapped is the difference between the maximum height and current height\n\nKey insight: We can safely move the pointer with the smaller height because:\n- The water level is limited by the smaller of the two maximum heights\n- We've already processed all positions that could trap water on that side\n\nExample: height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n- left = 0, right = 11, left_max = 0, right_max = 0\n- height[left] = 0 < height[right] = 1\n- left_max = 0, water += 0 - 0 = 0, left = 1\n- height[left] = 1 = height[right] = 1\n- right_max = 1, water += 1 - 1 = 0, right = 10\n- Continue...\n- Result: 6 units of water\n\nThe time complexity is O(n) as we only need one pass through the array. The space complexity is O(1) as we only use a constant amount of extra space."
  }
}

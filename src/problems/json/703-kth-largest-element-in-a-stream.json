{
  "id": 703,
  "title": "Kth Largest Element In a Stream",
  "list": ["neetcode150"],
  "category": "Heap / Priority Queue",
  "difficulty": "Easy",
  "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\nImplement KthLargest class:\n- KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\n- int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.",
  "constraints": [
    "1 <= k <= 104",
    "0 <= nums.length <= 104",
    "-104 <= nums[i] <= 104",
    "-104 <= val <= 104",
    "At most 104 calls will be made to add",
    "It is guaranteed that there will be at least k elements in the array when you search for the kth element"
  ],
  "testCases": [
    {
      "input": {
        "operations": ["KthLargest", "add", "add", "add", "add", "add"],
        "values": [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
      },
      "output": [null, 4, 5, 5, 8, 8],
      "explanation": "KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
    },
    {
      "input": {
        "operations": ["KthLargest", "add", "add", "add"],
        "values": [[1, []], [-3], [-2], [-4]]
      },
      "output": [null, -3, -2, -2],
      "explanation": "KthLargest kthLargest = new KthLargest(1, []);\nkthLargest.add(-3);  // return -3\nkthLargest.add(-2);  // return -2\nkthLargest.add(-4);  // return -2"
    }
  ],
  "solution": {
    "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n        self.k = k\n        # Use min heap to keep k largest elements\n        self.min_heap = []\n        \n        # Add initial elements\n        for num in nums:\n            self.add(num)\n    \n    def add(self, val: int) -> int:\n        # Add to heap\n        heapq.heappush(self.min_heap, val)\n        \n        # Keep only k largest elements\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        \n        # Return kth largest (smallest in min heap)\n        return self.min_heap[0]\n\n# Alternative approach with separate initialization\ndef KthLargestSeparate(k, nums):\n    class KthLargest:\n        def __init__(self, k: int, nums: list[int]):\n            self.k = k\n            self.min_heap = []\n            \n            # Initialize with first k elements\n            for num in nums:\n                if len(self.min_heap) < k:\n                    heapq.heappush(self.min_heap, num)\n                else:\n                    if num > self.min_heap[0]:\n                        heapq.heappushpop(self.min_heap, num)\n        \n        def add(self, val: int) -> int:\n            if len(self.min_heap) < self.k:\n                heapq.heappush(self.min_heap, val)\n            else:\n                if val > self.min_heap[0]:\n                    heapq.heappushpop(self.min_heap, val)\n            \n            return self.min_heap[0]\n    \n    return KthLargest(k, nums)\n\n# Alternative approach using max heap\ndef KthLargestMaxHeap(k, nums):\n    class KthLargest:\n        def __init__(self, k: int, nums: list[int]):\n            self.k = k\n            # Use max heap and keep only k elements\n            self.max_heap = []\n            \n            for num in nums:\n                heapq.heappush(self.max_heap, -num)\n                if len(self.max_heap) > k:\n                    heapq.heappop(self.max_heap)\n        \n        def add(self, val: int) -> int:\n            heapq.heappush(self.max_heap, -val)\n            if len(self.max_heap) > self.k:\n                heapq.heappop(self.max_heap)\n            \n            return -self.max_heap[0]\n    \n    return KthLargest(k, nums)\n\n# Alternative approach with sorting\ndef KthLargestSorting(k, nums):\n    class KthLargest:\n        def __init__(self, k: int, nums: list[int]):\n            self.k = k\n            self.nums = sorted(nums, reverse=True)[:k]\n        \n        def add(self, val: int) -> int:\n            # Insert val in sorted position\n            for i in range(len(self.nums)):\n                if val >= self.nums[i]:\n                    self.nums.insert(i, val)\n                    break\n            else:\n                self.nums.append(val)\n            \n            # Keep only k largest elements\n            self.nums = self.nums[:self.k]\n            \n            return self.nums[-1] if self.nums else None\n    \n    return KthLargest(k, nums)",
    "explanation": "Four approaches are shown:\n\n1. Min heap approach (recommended):\n   - Use a min heap to keep the k largest elements\n   - When adding a new element, push it to the heap\n   - If heap size exceeds k, pop the smallest element\n   - The kth largest is always the smallest element in the heap\n   - Time complexity: O(log k) for add operation\n   - Space complexity: O(k)\n\n2. Separate initialization approach:\n   - Initialize the heap with the first k elements\n   - Use heappushpop for efficient insertion and removal\n   - Same time and space complexity as first approach\n\n3. Max heap approach:\n   - Use a max heap but keep only k elements\n   - Negate values to simulate max heap with min heap\n   - Same logic but different implementation\n   - Time complexity: O(log k) for add operation\n   - Space complexity: O(k)\n\n4. Sorting approach:\n   - Maintain a sorted list of k largest elements\n   - Insert new elements in sorted position\n   - Less efficient but simpler to understand\n   - Time complexity: O(k) for add operation\n   - Space complexity: O(k)\n\nKey insight: We only need to keep track of the k largest elements, not all elements.\n\nExample with k=3 and initial nums=[4,5,8,2]:\n- Initial heap: [2,4,5,8] → keep [4,5,8]\n- Add 3: [3,4,5,8] → keep [4,5,8], return 4\n- Add 5: [4,5,5,8] → keep [4,5,8], return 4\n- Add 10: [4,5,8,10] → keep [5,8,10], return 5\n\nThe min heap approach is the most efficient and commonly used solution for this problem."
  }
}

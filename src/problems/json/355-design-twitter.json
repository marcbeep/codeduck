{
  "id": 355,
  "title": "Design Twitter",
  "list": ["neetcode150"],
  "category": "Heap / Priority Queue",
  "difficulty": "Medium",
  "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\n\nImplement the Twitter class:\n- Twitter() Initializes your twitter object.\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.",
  "constraints": [
    "1 <= userId, followerId, followeeId <= 500",
    "0 <= tweetId <= 104",
    "All the tweets have unique IDs",
    "At most 3 * 104 calls will be made to postTweet, getNewsFeed, follow, and unfollow"
  ],
  "testCases": [
    {
      "input": {
        "operations": [
          "Twitter",
          "postTweet",
          "getNewsFeed",
          "follow",
          "postTweet",
          "getNewsFeed",
          "unfollow",
          "getNewsFeed"
        ],
        "values": [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
      },
      "output": [null, null, [5], null, null, [6, 5], null, [5]],
      "explanation": "Twitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2."
    }
  ],
  "solution": {
    "code": "import heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        # User -> set of users they follow\n        self.following = defaultdict(set)\n        # User -> list of their tweets (tweetId, timestamp)\n        self.tweets = defaultdict(list)\n        # Global timestamp counter\n        self.time = 0\n    \n    def postTweet(self, userId: int, tweetId: int) -> None:\n        # Add tweet to user's tweet list with timestamp\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n    \n    def getNewsFeed(self, userId: int) -> list[int]:\n        # Get all tweets from user and users they follow\n        tweets = []\n        \n        # Add user's own tweets\n        tweets.extend(self.tweets[userId])\n        \n        # Add tweets from users they follow\n        for followeeId in self.following[userId]:\n            tweets.extend(self.tweets[followeeId])\n        \n        # Sort by timestamp (most recent first) and get top 10\n        tweets.sort(reverse=True)\n        return [tweet[1] for tweet in tweets[:10]]\n    \n    def follow(self, followerId: int, followeeId: int) -> None:\n        # Add followee to follower's following set\n        self.following[followerId].add(followeeId)\n    \n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        # Remove followee from follower's following set\n        if followeeId in self.following[followerId]:\n            self.following[followerId].remove(followeeId)\n\n# Alternative approach using heap for efficient news feed\ndef TwitterHeap():\n    class Twitter:\n        def __init__(self):\n            self.following = defaultdict(set)\n            self.tweets = defaultdict(list)\n            self.time = 0\n        \n        def postTweet(self, userId: int, tweetId: int) -> None:\n            self.tweets[userId].append((self.time, tweetId))\n            self.time += 1\n        \n        def getNewsFeed(self, userId: int) -> list[int]:\n            # Use max heap to get most recent tweets\n            heap = []\n            \n            # Add user's own tweets\n            for time, tweetId in self.tweets[userId]:\n                heapq.heappush(heap, (-time, tweetId))\n            \n            # Add tweets from users they follow\n            for followeeId in self.following[userId]:\n                for time, tweetId in self.tweets[followeeId]:\n                    heapq.heappush(heap, (-time, tweetId))\n            \n            # Get top 10 most recent tweets\n            result = []\n            for _ in range(min(10, len(heap))):\n                _, tweetId = heapq.heappop(heap)\n                result.append(tweetId)\n            \n            return result\n        \n        def follow(self, followerId: int, followeeId: int) -> None:\n            self.following[followerId].add(followeeId)\n        \n        def unfollow(self, followerId: int, followeeId: int) -> None:\n            if followeeId in self.following[followerId]:\n                self.following[followerId].remove(followeeId)\n    \n    return Twitter()\n\n# Alternative approach with separate Tweet class\ndef TwitterClass():\n    class Tweet:\n        def __init__(self, tweetId: int, timestamp: int):\n            self.tweetId = tweetId\n            self.timestamp = timestamp\n        \n        def __lt__(self, other):\n            return self.timestamp > other.timestamp  # For max heap\n    \n    class Twitter:\n        def __init__(self):\n            self.following = defaultdict(set)\n            self.tweets = defaultdict(list)\n            self.time = 0\n        \n        def postTweet(self, userId: int, tweetId: int) -> None:\n            tweet = Tweet(tweetId, self.time)\n            self.tweets[userId].append(tweet)\n            self.time += 1\n        \n        def getNewsFeed(self, userId: int) -> list[int]:\n            # Collect all relevant tweets\n            all_tweets = []\n            \n            # Add user's own tweets\n            all_tweets.extend(self.tweets[userId])\n            \n            # Add tweets from users they follow\n            for followeeId in self.following[userId]:\n                all_tweets.extend(self.tweets[followeeId])\n            \n            # Sort by timestamp and return top 10\n            all_tweets.sort(key=lambda x: x.timestamp, reverse=True)\n            return [tweet.tweetId for tweet in all_tweets[:10]]\n        \n        def follow(self, followerId: int, followeeId: int) -> None:\n            self.following[followerId].add(followeeId)\n        \n        def unfollow(self, followerId: int, followeeId: int) -> None:\n            if followeeId in self.following[followerId]:\n                self.following[followerId].remove(followeeId)\n    \n    return Twitter()\n\n# Alternative approach with optimized news feed\ndef TwitterOptimized():\n    class Twitter:\n        def __init__(self):\n            self.following = defaultdict(set)\n            self.tweets = defaultdict(list)\n            self.time = 0\n        \n        def postTweet(self, userId: int, tweetId: int) -> None:\n            self.tweets[userId].append((self.time, tweetId))\n            self.time += 1\n        \n        def getNewsFeed(self, userId: int) -> list[int]:\n            # Use merge sort approach for efficiency\n            tweets = []\n            \n            # Add user's own tweets\n            if userId in self.tweets:\n                tweets.extend(self.tweets[userId])\n            \n            # Add tweets from users they follow\n            for followeeId in self.following[userId]:\n                if followeeId in self.tweets:\n                    tweets.extend(self.tweets[followeeId])\n            \n            # Sort by timestamp and return top 10\n            tweets.sort(reverse=True)\n            return [tweet[1] for tweet in tweets[:10]]\n        \n        def follow(self, followerId: int, followeeId: int) -> None:\n            if followerId != followeeId:  # Users can't follow themselves\n                self.following[followerId].add(followeeId)\n        \n        def unfollow(self, followerId: int, followeeId: int) -> None:\n            if followeeId in self.following[followerId]:\n                self.following[followerId].remove(followeeId)\n    \n    return Twitter()",
    "explanation": "Four approaches are shown:\n\n1. Basic approach (recommended):\n   - Use defaultdict for following relationships and tweets\n   - Store tweets with timestamps for ordering\n   - Collect all relevant tweets and sort by timestamp\n   - Time complexity: O(n log n) for getNewsFeed where n is total tweets\n   - Space complexity: O(n) where n is total tweets\n\n2. Heap-based approach:\n   - Use max heap to efficiently get most recent tweets\n   - Push all relevant tweets to heap with negative timestamps\n   - Pop top 10 tweets\n   - Time complexity: O(n log n) for getNewsFeed\n   - Space complexity: O(n)\n\n3. Class-based approach:\n   - Create separate Tweet class for better organization\n   - Implement custom comparison for sorting\n   - More object-oriented design\n   - Same time and space complexity\n\n4. Optimized approach:\n   - Add edge case handling (users can't follow themselves)\n   - More efficient tweet collection\n   - Same core logic but with optimizations\n   - Same time and space complexity\n\nKey insight: We need to efficiently merge tweets from multiple users and sort by timestamp.\n\nExample with user 1 following user 2:\n- User 1 posts tweet 5 at time 0\n- User 2 posts tweet 6 at time 1\n- getNewsFeed(1) returns [6, 5] (most recent first)\n\nApplications: Social media feeds, real-time data streams, and more.\n\nThe basic approach is the most straightforward and commonly used solution for this problem."
  }
}

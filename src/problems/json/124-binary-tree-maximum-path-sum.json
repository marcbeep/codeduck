{
  "id": 124,
  "title": "Binary Tree Maximum Path Sum",
  "list": ["neetcode150"],
  "category": "Trees",
  "difficulty": "Hard",
  "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.",
  "constraints": [
    "The number of nodes in the tree is in the range [1, 3 * 104]",
    "-1000 <= Node.val <= 1000"
  ],
  "testCases": [
    {
      "input": {
        "root": [1, 2, 3]
      },
      "output": 6,
      "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."
    },
    {
      "input": {
        "root": [-10, 9, 20, null, null, 15, 7]
      },
      "output": 42,
      "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
    },
    {
      "input": {
        "root": [2, -1]
      },
      "output": 2,
      "explanation": "The optimal path is just the root node with value 2."
    },
    {
      "input": {
        "root": [-3]
      },
      "output": -3,
      "explanation": "The optimal path is just the root node with value -3."
    }
  ],
  "solution": {
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef maxPathSum(root):\n    # Global variable to track maximum path sum\n    max_sum = float('-inf')\n    \n    def dfs(node):\n        nonlocal max_sum\n        \n        if not node:\n            return 0\n        \n        # Get maximum path sum from left and right subtrees\n        left_sum = max(dfs(node.left), 0)\n        right_sum = max(dfs(node.right), 0)\n        \n        # Calculate path sum through current node\n        path_sum = node.val + left_sum + right_sum\n        \n        # Update global maximum\n        max_sum = max(max_sum, path_sum)\n        \n        # Return maximum path sum that can be extended by parent\n        return node.val + max(left_sum, right_sum)\n    \n    dfs(root)\n    return max_sum\n\n# Alternative approach using class variable\ndef maxPathSumClass(root):\n    class Solution:\n        def __init__(self):\n            self.max_sum = float('-inf')\n        \n        def maxPathSum(self, root):\n            def dfs(node):\n                if not node:\n                    return 0\n                \n                # Get maximum path sum from left and right subtrees\n                left_sum = max(dfs(node.left), 0)\n                right_sum = max(dfs(node.right), 0)\n                \n                # Calculate path sum through current node\n                path_sum = node.val + left_sum + right_sum\n                \n                # Update global maximum\n                self.max_sum = max(self.max_sum, path_sum)\n                \n                # Return maximum path sum that can be extended by parent\n                return node.val + max(left_sum, right_sum)\n            \n            dfs(root)\n            return self.max_sum\n    \n    return Solution().maxPathSum(root)\n\n# Alternative approach with explicit path tracking\ndef maxPathSumExplicit(root):\n    def dfs(node):\n        if not node:\n            return 0, float('-inf')\n        \n        # Get results from left and right subtrees\n        left_single, left_max = dfs(node.left)\n        right_single, right_max = dfs(node.right)\n        \n        # Calculate single path sum (can be extended by parent)\n        single_sum = node.val + max(left_single, right_single, 0)\n        \n        # Calculate path sum through current node\n        path_sum = node.val + max(left_single, 0) + max(right_single, 0)\n        \n        # Update maximum path sum\n        max_sum = max(path_sum, left_max, right_max)\n        \n        return single_sum, max_sum\n    \n    _, max_sum = dfs(root)\n    return max_sum\n\n# Alternative approach using iterative DFS\ndef maxPathSumIterative(root):\n    if not root:\n        return 0\n    \n    max_sum = float('-inf')\n    stack = [(root, False)]\n    node_sums = {None: 0}\n    \n    while stack:\n        node, processed = stack.pop()\n        \n        if processed:\n            # Calculate maximum path sum for current node\n            left_sum = max(node_sums.get(node.left, 0), 0)\n            right_sum = max(node_sums.get(node.right, 0), 0)\n            \n            # Path sum through current node\n            path_sum = node.val + left_sum + right_sum\n            max_sum = max(max_sum, path_sum)\n            \n            # Single path sum for parent\n            node_sums[node] = node.val + max(left_sum, right_sum)\n        else:\n            # Add node back to stack with processed=True\n            stack.append((node, True))\n            \n            # Add children to stack\n            if node.right:\n                stack.append((node.right, False))\n            if node.left:\n                stack.append((node.left, False))\n    \n    return max_sum",
    "explanation": "Four approaches are shown:\n\n1. Recursive DFS with global variable (recommended):\n   - Use DFS to traverse the tree\n   - For each node, calculate maximum path sum through it\n   - Keep track of global maximum path sum\n   - Return maximum single path sum for parent\n   - Time complexity: O(n) where n is the number of nodes\n   - Space complexity: O(h) where h is the height of the tree\n\n2. Class-based approach:\n   - Use a class to store the global maximum\n   - Same logic as the first approach\n   - More object-oriented design\n   - Time complexity: O(n)\n   - Space complexity: O(h)\n\n3. Explicit path tracking:\n   - Return both single path sum and maximum path sum\n   - More explicit about what each value represents\n   - Same time and space complexity\n\n4. Iterative DFS approach:\n   - Use a stack to simulate recursion\n   - Process nodes in post-order traversal\n   - Maintain a dictionary to store node sums\n   - Time complexity: O(n)\n   - Space complexity: O(n)\n\nKey insight: For each node, we need to consider:\n1. Path sum through the current node (left + node + right)\n2. Maximum single path sum that can be extended by parent (node + max(left, right))\n\nExample with [-10,9,20,null,null,15,7]:\n- Node 15: single=15, path=15\n- Node 7: single=7, path=7\n- Node 20: single=35 (20+15), path=42 (15+20+7)\n- Node 9: single=9, path=9\n- Node -10: single=25 (25+35), path=42 (max path)\n- Result: 42\n\nThe recursive DFS approach is the most elegant and commonly used solution for this problem."
  }
}

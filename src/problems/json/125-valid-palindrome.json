{
  "id": 125,
  "title": "Valid Palindrome",
  "list": ["grind75"],
  "category": "String",
  "difficulty": "Easy",
  "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
  "constraints": [
    "1 <= s.length <= 2 * 105",
    "s consists only of printable ASCII characters"
  ],
  "testCases": [
    {
      "input": {
        "s": "A man, a plan, a canal: Panama"
      },
      "output": true,
      "explanation": "After removing non-alphanumeric characters: 'amanaplanacanalpanama' which reads the same forward and backward."
    },
    {
      "input": {
        "s": "race a car"
      },
      "output": false,
      "explanation": "After removing non-alphanumeric characters: 'raceacar' which is not a palindrome."
    },
    {
      "input": {
        "s": " "
      },
      "output": true,
      "explanation": "An empty string is considered a palindrome."
    },
    {
      "input": {
        "s": "0P"
      },
      "output": false,
      "explanation": "After converting to lowercase: '0p' which is not a palindrome."
    }
  ],
  "solution": {
    "code": "def is_palindrome(s: str) -> bool:\n    # Convert to lowercase and filter alphanumeric characters\n    filtered = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Check if the filtered string is a palindrome\n    return filtered == filtered[::-1]\n\n# Alternative two-pointer approach\ndef is_palindrome_two_pointers(s: str) -> bool:\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric characters from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        # Skip non-alphanumeric characters from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True",
    "explanation": "Two approaches are shown:\n\n1. Filter approach: Convert to lowercase, filter alphanumeric characters, then check if the string equals its reverse.\n   - Time complexity: O(n)\n   - Space complexity: O(n) for the filtered string\n\n2. Two-pointer approach: Use two pointers from both ends, skip non-alphanumeric characters, and compare characters.\n   - Time complexity: O(n)\n   - Space complexity: O(1) as we only use constant extra space\n\nThe two-pointer approach is more space-efficient as it doesn't create a new string."
  }
}

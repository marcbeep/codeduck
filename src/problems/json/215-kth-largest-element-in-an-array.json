{
  "id": 215,
  "title": "Kth Largest Element In An Array",
  "list": ["neetcode150"],
  "category": "Heap / Priority Queue",
  "difficulty": "Medium",
  "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\n\nCan you solve it without sorting?",
  "constraints": ["1 <= k <= nums.length <= 105", "-104 <= nums[i] <= 104"],
  "testCases": [
    {
      "input": {
        "nums": [3, 2, 1, 5, 6, 4],
        "k": 2
      },
      "output": 5,
      "explanation": "The 2nd largest element is 5."
    },
    {
      "input": {
        "nums": [3, 2, 3, 1, 2, 4, 5, 5, 6],
        "k": 4
      },
      "output": 4,
      "explanation": "The 4th largest element is 4."
    },
    {
      "input": {
        "nums": [1],
        "k": 1
      },
      "output": 1,
      "explanation": "The 1st largest element is 1."
    }
  ],
  "solution": {
    "code": "import heapq\n\ndef findKthLargest(nums, k):\n    # Use min heap to keep k largest elements\n    min_heap = []\n    \n    for num in nums:\n        heapq.heappush(min_heap, num)\n        # Keep only k largest elements\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    \n    # The kth largest is the smallest in the heap\n    return min_heap[0]\n\n# Alternative approach using max heap\ndef findKthLargestMaxHeap(nums, k):\n    # Convert to max heap by negating values\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n    \n    # Pop k-1 elements to get to kth largest\n    for _ in range(k - 1):\n        heapq.heappop(max_heap)\n    \n    # Return the kth largest\n    return -max_heap[0]\n\n# Alternative approach using quickselect\ndef findKthLargestQuickSelect(nums, k):\n    def partition(left, right, pivot_index):\n        pivot = nums[pivot_index]\n        # Move pivot to end\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        \n        # Move all smaller elements to the left\n        store_index = left\n        for i in range(left, right):\n            if nums[i] < pivot:\n                nums[store_index], nums[i] = nums[i], nums[store_index]\n                store_index += 1\n        \n        # Move pivot to its final place\n        nums[right], nums[store_index] = nums[store_index], nums[right]\n        \n        return store_index\n    \n    def select(left, right, k_smallest):\n        if left == right:\n            return nums[left]\n        \n        # Select a random pivot\n        import random\n        pivot_index = random.randint(left, right)\n        \n        # Find the pivot position in a sorted array\n        pivot_index = partition(left, right, pivot_index)\n        \n        # The pivot is in its final sorted position\n        if k_smallest == pivot_index:\n            return nums[k_smallest]\n        elif k_smallest < pivot_index:\n            return select(left, pivot_index - 1, k_smallest)\n        else:\n            return select(pivot_index + 1, right, k_smallest)\n    \n    # kth largest is the same as (n-k)th smallest\n    return select(0, len(nums) - 1, len(nums) - k)\n\n# Alternative approach using sorting\ndef findKthLargestSorting(nums, k):\n    # Sort in descending order and return kth element\n    nums.sort(reverse=True)\n    return nums[k - 1]\n\n# Alternative approach using built-in heapq.nlargest\ndef findKthLargestBuiltin(nums, k):\n    # Use heapq.nlargest to get k largest elements\n    k_largest = heapq.nlargest(k, nums)\n    return k_largest[-1]  # Return the kth largest\n\n# Alternative approach with custom heap implementation\ndef findKthLargestCustom(nums, k):\n    class MinHeap:\n        def __init__(self):\n            self.heap = []\n        \n        def push(self, val):\n            self.heap.append(val)\n            self._bubble_up(len(self.heap) - 1)\n        \n        def pop(self):\n            if not self.heap:\n                return None\n            \n            if len(self.heap) == 1:\n                return self.heap.pop()\n            \n            # Swap root with last element\n            self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]\n            val = self.heap.pop()\n            self._bubble_down(0)\n            return val\n        \n        def peek(self):\n            return self.heap[0] if self.heap else None\n        \n        def size(self):\n            return len(self.heap)\n        \n        def _bubble_up(self, index):\n            parent = (index - 1) // 2\n            if parent >= 0 and self.heap[parent] > self.heap[index]:\n                self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent]\n                self._bubble_up(parent)\n        \n        def _bubble_down(self, index):\n            left = 2 * index + 1\n            right = 2 * index + 2\n            smallest = index\n            \n            if left < len(self.heap) and self.heap[left] < self.heap[smallest]:\n                smallest = left\n            if right < len(self.heap) and self.heap[right] < self.heap[smallest]:\n                smallest = right\n            \n            if smallest != index:\n                self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]\n                self._bubble_down(smallest)\n    \n    heap = MinHeap()\n    for num in nums:\n        heap.push(num)\n        if heap.size() > k:\n            heap.pop()\n    \n    return heap.peek()",
    "explanation": "Six approaches are shown:\n\n1. Min heap approach (recommended):\n   - Use a min heap to keep the k largest elements\n   - For each element, add to heap and remove smallest if heap size > k\n   - The kth largest is the smallest element in the heap\n   - Time complexity: O(n log k)\n   - Space complexity: O(k)\n\n2. Max heap approach:\n   - Use a max heap and pop k-1 elements\n   - The kth largest is the top of the heap\n   - Time complexity: O(n + k log n)\n   - Space complexity: O(n)\n\n3. Quickselect approach:\n   - Use the quickselect algorithm (similar to quicksort)\n   - Partition around a pivot and recursively select\n   - Average time complexity: O(n)\n   - Space complexity: O(1)\n\n4. Sorting approach:\n   - Sort the array and return the kth element\n   - Simple but less efficient\n   - Time complexity: O(n log n)\n   - Space complexity: O(1)\n\n5. Built-in heapq approach:\n   - Use Python's heapq.nlargest function\n   - Clean and efficient\n   - Time complexity: O(n log k)\n   - Space complexity: O(k)\n\n6. Custom heap implementation:\n   - Implement min heap from scratch\n   - Educational but not practical\n   - Time complexity: O(n log k)\n   - Space complexity: O(k)\n\nKey insight: We can find the kth largest element without sorting the entire array.\n\nExample with [3,2,1,5,6,4] and k=2:\n- Min heap approach: keep [5,6], return 5\n- Max heap approach: pop 6, return 5\n- Quickselect: partition around pivot, find 2nd largest\n- Result: 5\n\nThe min heap approach is the most efficient for this problem when k is much smaller than n."
  }
}

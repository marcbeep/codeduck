{
  "id": 271,
  "title": "Encode and Decode Strings",
  "list": ["neetcode150"],
  "category": "Arrays & Hashing",
  "difficulty": "Medium",
  "description": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nPlease implement encode and decode.",
  "constraints": [
    "1 <= strs.length <= 200",
    "0 <= strs[i].length <= 200",
    "strs[i] contains any possible characters out of 256 valid ASCII characters"
  ],
  "testCases": [
    {
      "input": {
        "strs": ["Hello", "World"]
      },
      "output": ["Hello", "World"],
      "explanation": "Encode: '5#Hello5#World', Decode: ['Hello', 'World']"
    },
    {
      "input": {
        "strs": [""]
      },
      "output": [""],
      "explanation": "Encode: '0#', Decode: ['']"
    },
    {
      "input": {
        "strs": ["Hello", "", "World"]
      },
      "output": ["Hello", "", "World"],
      "explanation": "Encode: '5#Hello0#5#World', Decode: ['Hello', '', 'World']"
    }
  ],
  "solution": {
    "code": "class Codec:\n    def encode(self, strs: list[str]) -> str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n        for s in strs:\n            # Format: length#string\n            encoded += str(len(s)) + \"#\" + s\n        return encoded\n    \n    def decode(self, s: str) -> list[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        result = []\n        i = 0\n        \n        while i < len(s):\n            # Find the delimiter '#'\n            delimiter_pos = s.find('#', i)\n            \n            # Extract length\n            length = int(s[i:delimiter_pos])\n            \n            # Extract string\n            start = delimiter_pos + 1\n            end = start + length\n            result.append(s[start:end])\n            \n            # Move to next string\n            i = end\n        \n        return result\n\n# Alternative approach using different delimiter\ndef encode_alternative(strs: list[str]) -> str:\n    \"\"\"Alternative encoding using a different delimiter\"\"\"\n    if not strs:\n        return \"\"\n    \n    # Join strings with a special delimiter\n    return \"\\0\".join(strs)\n\ndef decode_alternative(s: str) -> list[str]:\n    \"\"\"Alternative decoding using a different delimiter\"\"\"\n    if not s:\n        return []\n    \n    # Split by the special delimiter\n    return s.split(\"\\0\")",
    "explanation": "Two approaches are shown:\n\n1. Length-prefix approach:\n   - Encode: For each string, store its length followed by '#' and then the string\n   - Format: 'length#string'\n   - Example: ['Hello', 'World'] -> '5#Hello5#World'\n   - Decode: Parse length, then extract the string of that length\n   - Time complexity: O(n) where n is total length of all strings\n   - Space complexity: O(n)\n\n2. Delimiter approach:\n   - Use a special character (like null byte) as delimiter\n   - Join all strings with this delimiter\n   - Split by delimiter to decode\n   - Simpler but less robust if strings contain the delimiter\n   - Time complexity: O(n)\n   - Space complexity: O(n)\n\nThe length-prefix approach is more robust and commonly used in practice, as it handles any character in the strings."
  }
}

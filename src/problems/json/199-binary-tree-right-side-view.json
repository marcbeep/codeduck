{
  "id": 199,
  "title": "Binary Tree Right Side View",
  "list": ["grind75"],
  "category": "Trees",
  "difficulty": "Medium",
  "description": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
  "constraints": [
    "The number of nodes in the tree is in the range [0, 100]",
    "-100 <= Node.val <= 100"
  ],
  "testCases": [
    {
      "input": {
        "root": [1, 2, 3, null, 5, null, 4]
      },
      "output": [1, 3, 4],
      "explanation": "When standing on the right side, you can see nodes 1, 3, and 4."
    },
    {
      "input": {
        "root": [1, null, 3]
      },
      "output": [1, 3],
      "explanation": "When standing on the right side, you can see nodes 1 and 3."
    },
    {
      "input": {
        "root": []
      },
      "output": [],
      "explanation": "Empty tree has no right side view."
    }
  ],
  "solution": {
    "code": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef rightSideView(root: TreeNode) -> list[int]:\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        \n        for i in range(level_size):\n            node = queue.popleft()\n            \n            # Add rightmost node of each level\n            if i == level_size - 1:\n                result.append(node.val)\n            \n            # Add children to queue\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    \n    return result",
    "explanation": "This solution uses level-order traversal (BFS) to find the rightmost node at each level:\n1. We use a queue to perform level-order traversal\n2. For each level, we process all nodes at that level\n3. We add the rightmost node (last node) of each level to our result\n4. We add children to the queue for the next level\n5. We continue until the queue is empty\n\nExample: root = [1, 2, 3, null, 5, null, 4]\n- Level 0: [1] → add 1 to result\n- Level 1: [2, 3] → add 3 (rightmost) to result\n- Level 2: [5, 4] → add 4 (rightmost) to result\n- Result: [1, 3, 4]\n\nAlternative approach using DFS:\n- We can also use DFS with a depth parameter\n- We keep track of the maximum depth visited\n- We add nodes only if we haven't seen this depth before\n- We visit right child first to ensure we get the rightmost node\n\nThe time complexity is O(n) as we visit each node exactly once. The space complexity is O(w) where w is the maximum width of the tree."
  }
}

{
  "id": 409,
  "title": "Longest Palindrome",
  "list": ["grind75"],
  "category": "String",
  "difficulty": "Easy",
  "description": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\n\nLetters are case sensitive, for example, \"Aa\" is not considered a palindrome here.",
  "constraints": [
    "1 <= s.length <= 2000",
    "s consists of lowercase and/or uppercase English letters only"
  ],
  "testCases": [
    {
      "input": {
        "s": "abccccdd"
      },
      "output": 7,
      "explanation": "One longest palindrome that can be built is \"dccaccd\", whose length is 7."
    },
    {
      "input": {
        "s": "a"
      },
      "output": 1,
      "explanation": "The longest palindrome that can be built is \"a\", whose length is 1."
    },
    {
      "input": {
        "s": "bb"
      },
      "output": 2,
      "explanation": "The longest palindrome that can be built is \"bb\", whose length is 2."
    },
    {
      "input": {
        "s": "ccc"
      },
      "output": 3,
      "explanation": "The longest palindrome that can be built is \"ccc\", whose length is 3."
    }
  ],
  "solution": {
    "code": "def longest_palindrome(s: str) -> int:\n    # Count frequency of each character\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    length = 0\n    has_odd = False\n    \n    # For each character count\n    for count in char_count.values():\n        # Add even pairs to length\n        length += (count // 2) * 2\n        \n        # Check if we have any odd counts\n        if count % 2 == 1:\n            has_odd = True\n    \n    # Add 1 for the center character if we have any odd counts\n    if has_odd:\n        length += 1\n    \n    return length\n\n# Alternative approach using Counter\ndef longest_palindrome_counter(s: str) -> int:\n    from collections import Counter\n    \n    # Count characters\n    char_count = Counter(s)\n    \n    length = 0\n    has_odd = False\n    \n    for count in char_count.values():\n        length += (count // 2) * 2\n        if count % 2 == 1:\n            has_odd = True\n    \n    return length + (1 if has_odd else 0)\n\n# Alternative approach using set\ndef longest_palindrome_set(s: str) -> int:\n    # Use a set to track characters with odd counts\n    odd_chars = set()\n    \n    for char in s:\n        if char in odd_chars:\n            odd_chars.remove(char)\n        else:\n            odd_chars.add(char)\n    \n    # Length = total characters - odd characters + 1 (if there are odd characters)\n    return len(s) - len(odd_chars) + (1 if odd_chars else 0)\n\n# Alternative approach using list for character counting\ndef longest_palindrome_list(s: str) -> int:\n    # Use a list to count characters (assuming ASCII)\n    char_count = [0] * 128\n    \n    for char in s:\n        char_count[ord(char)] += 1\n    \n    length = 0\n    has_odd = False\n    \n    for count in char_count:\n        if count > 0:\n            length += (count // 2) * 2\n            if count % 2 == 1:\n                has_odd = True\n    \n    return length + (1 if has_odd else 0)",
    "explanation": "Four approaches are shown:\n\n1. Hash table approach (recommended):\n   - Count frequency of each character\n   - For each character, add even pairs to length\n   - If any character has odd count, add 1 for center\n   - Time complexity: O(n) where n is the length of string\n   - Space complexity: O(k) where k is the number of unique characters\n\n2. Counter approach:\n   - Use Python's Counter class for cleaner code\n   - Same logic as hash table approach\n   - Time complexity: O(n)\n   - Space complexity: O(k)\n\n3. Set approach:\n   - Use a set to track characters with odd counts\n   - Toggle characters in/out of set as we encounter them\n   - Calculate length using total length minus odd characters\n   - Time complexity: O(n)\n   - Space complexity: O(k)\n\n4. List approach:\n   - Use a fixed-size list for character counting\n   - Assumes ASCII characters\n   - More memory efficient for this specific case\n   - Time complexity: O(n)\n   - Space complexity: O(1) since the list size is fixed\n\nThe hash table approach is the most general and readable solution. The key insight is that we can use all even pairs of characters and at most one odd character for the center."
  }
}

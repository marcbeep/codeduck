{
  "id": 104,
  "title": "Maximum Depth of Binary Tree",
  "list": ["grind75", "neetcode150"],
  "category": "Trees",
  "difficulty": "Easy",
  "description": "Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
  "constraints": [
    "The number of nodes in the tree is in the range [0, 104]",
    "-100 <= Node.val <= 100"
  ],
  "testCases": [
    {
      "input": {
        "root": [3, 9, 20, null, null, 15, 7]
      },
      "output": 3,
      "explanation": "The maximum depth is 3: root (3) -> left child (9) -> left child (null), or root (3) -> right child (20) -> left child (15)."
    },
    {
      "input": {
        "root": [1, null, 2]
      },
      "output": 2,
      "explanation": "The maximum depth is 2: root (1) -> right child (2)."
    },
    {
      "input": {
        "root": []
      },
      "output": 0,
      "explanation": "An empty tree has depth 0."
    },
    {
      "input": {
        "root": [1]
      },
      "output": 1,
      "explanation": "A single node tree has depth 1."
    }
  ],
  "solution": {
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef max_depth(root):\n    # Recursive approach (DFS)\n    if not root:\n        return 0\n    \n    # Recursively find depth of left and right subtrees\n    left_depth = max_depth(root.left)\n    right_depth = max_depth(root.right)\n    \n    # Return the maximum depth plus 1 for current node\n    return max(left_depth, right_depth) + 1\n\n# Alternative iterative approach using BFS\ndef max_depth_bfs(root):\n    if not root:\n        return 0\n    \n    # Use a queue for BFS\n    queue = [(root, 1)]  # (node, depth)\n    max_depth = 0\n    \n    while queue:\n        node, depth = queue.pop(0)\n        max_depth = max(max_depth, depth)\n        \n        # Add children to queue\n        if node.left:\n            queue.append((node.left, depth + 1))\n        if node.right:\n            queue.append((node.right, depth + 1))\n    \n    return max_depth\n\n# Alternative iterative approach using DFS with stack\ndef max_depth_dfs_iterative(root):\n    if not root:\n        return 0\n    \n    # Use a stack for DFS\n    stack = [(root, 1)]  # (node, depth)\n    max_depth = 0\n    \n    while stack:\n        node, depth = stack.pop()\n        max_depth = max(max_depth, depth)\n        \n        # Add children to stack (right first for left-to-right traversal)\n        if node.right:\n            stack.append((node.right, depth + 1))\n        if node.left:\n            stack.append((node.left, depth + 1))\n    \n    return max_depth\n\n# Alternative approach using level-order traversal\ndef max_depth_level_order(root):\n    if not root:\n        return 0\n    \n    # Use a queue for level-order traversal\n    queue = [root]\n    depth = 0\n    \n    while queue:\n        # Process all nodes at current level\n        level_size = len(queue)\n        \n        for _ in range(level_size):\n            node = queue.pop(0)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        depth += 1\n    \n    return depth\n\n# Alternative approach using post-order traversal\ndef max_depth_postorder(root):\n    if not root:\n        return 0\n    \n    # Post-order traversal: left, right, root\n    left_depth = max_depth_postorder(root.left)\n    right_depth = max_depth_postorder(root.right)\n    \n    # Return maximum depth of subtrees plus 1\n    return max(left_depth, right_depth) + 1",
    "explanation": "Five approaches are shown:\n\n1. Recursive approach (recommended):\n   - Use recursion to find depth of left and right subtrees\n   - Return maximum of left and right depths plus 1\n   - Simple and elegant solution\n   - Time complexity: O(n) where n is the number of nodes\n   - Space complexity: O(h) where h is the height of the tree\n\n2. BFS approach:\n   - Use a queue to process nodes level by level\n   - Keep track of depth for each node\n   - Update maximum depth as we process nodes\n   - Time complexity: O(n)\n   - Space complexity: O(w) where w is the maximum width of the tree\n\n3. DFS iterative approach:\n   - Use a stack to simulate recursion\n   - Process nodes in depth-first order\n   - Keep track of depth for each node\n   - Time complexity: O(n)\n   - Space complexity: O(h)\n\n4. Level-order traversal approach:\n   - Process nodes level by level\n   - Count the number of levels\n   - More explicit level counting\n   - Time complexity: O(n)\n   - Space complexity: O(w)\n\n5. Post-order traversal approach:\n   - Same as recursive approach but explicitly shows post-order nature\n   - Process left subtree, then right subtree, then root\n   - Time complexity: O(n)\n   - Space complexity: O(h)\n\nThe recursive approach is the most commonly used and elegant solution for this problem."
  }
}

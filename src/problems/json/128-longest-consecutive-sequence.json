{
  "id": 128,
  "title": "Longest Consecutive Sequence",
  "list": ["neetcode150"],
  "category": "Arrays & Hashing",
  "difficulty": "Medium",
  "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.",
  "constraints": ["0 <= nums.length <= 105", "-109 <= nums[i] <= 109"],
  "testCases": [
    {
      "input": {
        "nums": [100, 4, 200, 1, 3, 2]
      },
      "output": 4,
      "explanation": "The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4."
    },
    {
      "input": {
        "nums": [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
      },
      "output": 9,
      "explanation": "The longest consecutive elements sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8]. Therefore its length is 9."
    },
    {
      "input": {
        "nums": []
      },
      "output": 0,
      "explanation": "Empty array has no consecutive sequence."
    }
  ],
  "solution": {
    "code": "def longest_consecutive(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    \n    # Convert to set for O(1) lookup\n    num_set = set(nums)\n    max_length = 0\n    \n    for num in num_set:\n        # Only start counting from the smallest number in a sequence\n        # (i.e., if num-1 exists, skip this num as it's not the start)\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            # Count consecutive numbers starting from current_num\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Alternative approach using sorting (O(n log n))\ndef longest_consecutive_sorting(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    \n    # Sort the array\n    nums.sort()\n    \n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, len(nums)):\n        # If current number is consecutive to previous\n        if nums[i] == nums[i-1] + 1:\n            current_length += 1\n        # If current number is same as previous, continue\n        elif nums[i] == nums[i-1]:\n            continue\n        # If not consecutive, reset current length\n        else:\n            current_length = 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length",
    "explanation": "Two approaches are shown:\n\n1. Hash Set approach (O(n)):\n   - Convert array to set for O(1) lookup\n   - For each number, check if it's the start of a sequence (num-1 doesn't exist)\n   - If it is the start, count consecutive numbers forward\n   - Track the maximum length found\n   - Time complexity: O(n) as each number is visited at most twice\n   - Space complexity: O(n) for the set\n\n2. Sorting approach (O(n log n)):\n   - Sort the array first\n   - Iterate through sorted array and count consecutive sequences\n   - Handle duplicates by skipping them\n   - Time complexity: O(n log n) due to sorting\n   - Space complexity: O(1) if we can modify the input array\n\nThe hash set approach is more efficient and meets the O(n) requirement. The key insight is to only start counting from the smallest number in each sequence to avoid redundant work."
  }
}

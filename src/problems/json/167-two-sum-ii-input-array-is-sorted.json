{
  "id": 167,
  "title": "Two Sum II - Input Array Is Sorted",
  "list": ["neetcode150"],
  "category": "Two Pointers",
  "difficulty": "Medium",
  "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.",
  "constraints": [
    "2 <= numbers.length <= 3 * 104",
    "-1000 <= numbers[i] <= 1000",
    "numbers is sorted in non-decreasing order",
    "-1000 <= target <= 1000",
    "The tests are generated such that there is exactly one solution"
  ],
  "testCases": [
    {
      "input": {
        "numbers": [2, 7, 11, 15],
        "target": 9
      },
      "output": [1, 2],
      "explanation": "The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]."
    },
    {
      "input": {
        "numbers": [2, 3, 4],
        "target": 6
      },
      "output": [1, 3],
      "explanation": "The sum of 2 and 4 is 6. Therefore, index1 = 1, index2 = 3. We return [1, 3]."
    },
    {
      "input": {
        "numbers": [-1, 0],
        "target": -1
      },
      "output": [1, 2],
      "explanation": "The sum of -1 and 0 is -1. Therefore, index1 = 1, index2 = 2. We return [1, 2]."
    }
  ],
  "solution": {
    "code": "def two_sum(numbers: list[int], target: int) -> list[int]:\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            # Return 1-indexed positions\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            # Need a larger sum, move left pointer right\n            left += 1\n        else:\n            # Need a smaller sum, move right pointer left\n            right -= 1\n    \n    # This should never be reached given the problem constraints\n    return []",
    "explanation": "This solution uses the two-pointer approach:\n1. We start with two pointers at the beginning and end of the sorted array\n2. We calculate the sum of the elements at both pointers\n3. If the sum equals the target, we return the 1-indexed positions\n4. If the sum is less than target, we move the left pointer right to get a larger sum\n5. If the sum is greater than target, we move the right pointer left to get a smaller sum\n6. We continue until we find the target sum\n\nKey insights:\n- Since the array is sorted, we can use two pointers efficiently\n- Moving the left pointer right increases the sum\n- Moving the right pointer left decreases the sum\n- We can eliminate half the search space in each iteration\n- The solution is guaranteed to exist by problem constraints\n\nExample: numbers = [2, 7, 11, 15], target = 9\n- left = 0 (2), right = 3 (15), sum = 2 + 15 = 17 > 9\n- Move right pointer: left = 0 (2), right = 2 (11), sum = 2 + 11 = 13 > 9\n- Move right pointer: left = 0 (2), right = 1 (7), sum = 2 + 7 = 9 = target\n- Return [1, 2] (1-indexed)\n\nThe time complexity is O(n) as we only need one pass through the array. The space complexity is O(1) as we only use constant extra space."
  }
}

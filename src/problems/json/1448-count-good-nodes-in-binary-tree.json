{
  "id": 1448,
  "title": "Count Good Nodes In Binary Tree",
  "list": ["neetcode150"],
  "category": "Trees",
  "difficulty": "Medium",
  "description": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\n\nReturn the number of good nodes in the binary tree.",
  "constraints": [
    "The number of nodes in the binary tree is in the range [1, 10^5]",
    "Each node's value is between [-10^4, 10^4]"
  ],
  "testCases": [
    {
      "input": {
        "root": [3, 1, 4, 3, null, 1, 5]
      },
      "output": 4,
      "explanation": "Nodes in blue are good. Root Node (3) is always a good node. Node 4 -> (3,4) is the maximum value in the path starting from the root. Node 5 -> (3,4,5) is the maximum value in the path. Node 3 -> (3,1,3) is the maximum value in the path."
    },
    {
      "input": {
        "root": [3, 3, null, 4, 2]
      },
      "output": 3,
      "explanation": "Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it."
    },
    {
      "input": {
        "root": [1]
      },
      "output": 1,
      "explanation": "Root is considered as good."
    },
    {
      "input": {
        "root": [9, null, 3, 6]
      },
      "output": 1,
      "explanation": "Only the root node is good since all other nodes have values less than 9."
    }
  ],
  "solution": {
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef goodNodes(root):\n    def dfs(node, max_val):\n        if not node:\n            return 0\n        \n        # Count current node if it's good\n        count = 1 if node.val >= max_val else 0\n        \n        # Update max_val for children\n        new_max = max(max_val, node.val)\n        \n        # Recursively count good nodes in left and right subtrees\n        count += dfs(node.left, new_max)\n        count += dfs(node.right, new_max)\n        \n        return count\n    \n    return dfs(root, float('-inf'))\n\n# Alternative approach using iterative DFS\ndef goodNodesIterative(root):\n    if not root:\n        return 0\n    \n    stack = [(root, float('-inf'))]\n    count = 0\n    \n    while stack:\n        node, max_val = stack.pop()\n        \n        # Count current node if it's good\n        if node.val >= max_val:\n            count += 1\n        \n        # Update max_val for children\n        new_max = max(max_val, node.val)\n        \n        # Add children to stack\n        if node.right:\n            stack.append((node.right, new_max))\n        if node.left:\n            stack.append((node.left, new_max))\n    \n    return count\n\n# Alternative approach using BFS\ndef goodNodesBFS(root):\n    if not root:\n        return 0\n    \n    queue = [(root, float('-inf'))]\n    count = 0\n    \n    while queue:\n        node, max_val = queue.pop(0)\n        \n        # Count current node if it's good\n        if node.val >= max_val:\n            count += 1\n        \n        # Update max_val for children\n        new_max = max(max_val, node.val)\n        \n        # Add children to queue\n        if node.left:\n            queue.append((node.left, new_max))\n        if node.right:\n            queue.append((node.right, new_max))\n    \n    return count\n\n# Alternative approach with separate helper function\ndef goodNodesHelper(root):\n    def countGoodNodes(node, path_max):\n        if not node:\n            return 0\n        \n        # Check if current node is good\n        is_good = node.val >= path_max\n        \n        # Update path maximum\n        current_max = max(path_max, node.val)\n        \n        # Count good nodes in subtrees\n        left_count = countGoodNodes(node.left, current_max)\n        right_count = countGoodNodes(node.right, current_max)\n        \n        return (1 if is_good else 0) + left_count + right_count\n    \n    return countGoodNodes(root, float('-inf'))",
    "explanation": "Four approaches are shown:\n\n1. Recursive DFS approach (recommended):\n   - Use DFS to traverse the tree\n   - Keep track of the maximum value seen in the current path\n   - Count nodes that are >= the path maximum\n   - Time complexity: O(n) where n is the number of nodes\n   - Space complexity: O(h) where h is the height of the tree\n\n2. Iterative DFS approach:\n   - Use a stack to simulate recursion\n   - Process nodes in depth-first order\n   - Maintain path maximum for each node\n   - Time complexity: O(n)\n   - Space complexity: O(h)\n\n3. BFS approach:\n   - Use a queue for level-order traversal\n   - Process nodes level by level\n   - Maintain path maximum for each node\n   - Time complexity: O(n)\n   - Space complexity: O(w) where w is the maximum width\n\n4. Helper function approach:\n   - Separate the logic into a helper function\n   - More explicit about what constitutes a good node\n   - Same time and space complexity as recursive approach\n\nKey insight: A node is good if its value is >= the maximum value in the path from root to that node.\n\nExample with [3,1,4,3,null,1,5]:\n- Root (3): good (max=3)\n- Node 1: not good (max=3, 1<3)\n- Node 4: good (max=4)\n- Node 3: good (max=3)\n- Node 1: good (max=4, 1<4 but path max=4)\n- Node 5: good (max=5)\n- Result: 4 good nodes\n\nThe recursive DFS approach is the most elegant and commonly used solution for this problem."
  }
}

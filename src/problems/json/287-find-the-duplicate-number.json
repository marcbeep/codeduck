{
  "id": 287,
  "title": "Find The Duplicate Number",
  "list": ["neetcode150"],
  "category": "Linked List",
  "difficulty": "Medium",
  "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one repeated number in nums, return this repeated number.\n\nYou must solve the problem without modifying the array nums and uses only constant extra space.",
  "constraints": [
    "1 <= n <= 105",
    "nums.length == n + 1",
    "1 <= nums[i] <= n",
    "All the integers in nums appear only once except for precisely one integer which appears two or more times"
  ],
  "testCases": [
    {
      "input": {
        "nums": [1, 3, 4, 2, 2]
      },
      "output": 2,
      "explanation": "The duplicate number is 2."
    },
    {
      "input": {
        "nums": [3, 1, 3, 4, 2]
      },
      "output": 3,
      "explanation": "The duplicate number is 3."
    },
    {
      "input": {
        "nums": [1, 1]
      },
      "output": 1,
      "explanation": "The duplicate number is 1."
    },
    {
      "input": {
        "nums": [1, 1, 2]
      },
      "output": 1,
      "explanation": "The duplicate number is 1."
    }
  ],
  "solution": {
    "code": "def findDuplicate(nums):\n    # Floyd's Tortoise and Hare (Cycle Detection)\n    # Treat the array as a linked list where nums[i] points to nums[nums[i]]\n    \n    # Phase 1: Find the intersection point\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    \n    # Phase 2: Find the entrance to the cycle\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow\n\n# Alternative approach using binary search\ndef findDuplicateBinarySearch(nums):\n    left, right = 1, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        # Count numbers <= mid\n        for num in nums:\n            if num <= mid:\n                count += 1\n        \n        # If count > mid, duplicate is in left half\n        if count > mid:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Alternative approach using bit manipulation\ndef findDuplicateBitManipulation(nums):\n    # This approach modifies the array, so it doesn't meet the constraints\n    # but shows an interesting technique\n    \n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] < 0:\n            return abs(num)\n        nums[index] = -nums[index]\n    \n    return -1\n\n# Alternative approach using sum and square sum\ndef findDuplicateMath(nums):\n    n = len(nums) - 1\n    \n    # Calculate expected sum and square sum\n    expected_sum = n * (n + 1) // 2\n    expected_square_sum = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate actual sum and square sum\n    actual_sum = sum(nums)\n    actual_square_sum = sum(x * x for x in nums)\n    \n    # Let x be the duplicate number\n    # actual_sum = expected_sum + x\n    # actual_square_sum = expected_square_sum + x^2\n    \n    x = actual_sum - expected_sum\n    x_squared = actual_square_sum - expected_square_sum\n    \n    # Solve: x^2 = x_squared\n    # This gives us the duplicate number\n    \n    return x",
    "explanation": "Four approaches are shown:\n\n1. Floyd's Tortoise and Hare (recommended):\n   - Treat the array as a linked list where nums[i] points to nums[nums[i]]\n   - The duplicate creates a cycle in this linked list\n   - Use Floyd's algorithm to find the cycle entrance\n   - Time complexity: O(n)\n   - Space complexity: O(1)\n\n2. Binary search approach:\n   - Search for the duplicate in the range [1, n]\n   - For each mid value, count how many numbers <= mid\n   - If count > mid, duplicate is in left half\n   - Time complexity: O(n log n)\n   - Space complexity: O(1)\n\n3. Bit manipulation approach:\n   - Mark visited numbers by making them negative\n   - When we encounter a negative number, we found the duplicate\n   - Note: This modifies the array, violating constraints\n   - Time complexity: O(n)\n   - Space complexity: O(1)\n\n4. Mathematical approach:\n   - Use sum and square sum to find the duplicate\n   - Solve equations: actual_sum = expected_sum + x\n   - Time complexity: O(n)\n   - Space complexity: O(1)\n\nKey insight: Floyd's algorithm is the most elegant solution that meets all constraints.\n\nExample with [1,3,4,2,2]:\n- Linked list: 1→3→2→4→2→4→2→4... (cycle at 2)\n- Phase 1: Find intersection (both pointers meet at 4)\n- Phase 2: Find cycle entrance (both start from beginning and intersection)\n- Result: 2 is the duplicate\n\nFloyd's algorithm is the standard solution for this problem."
  }
}

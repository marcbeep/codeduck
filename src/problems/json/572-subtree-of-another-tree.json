{
  "id": 572,
  "title": "Subtree of Another Tree",
  "list": ["neetcode150"],
  "category": "Trees",
  "difficulty": "Easy",
  "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\n\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
  "constraints": [
    "The number of nodes in the root tree is in the range [1, 2000]",
    "The number of nodes in the subRoot tree is in the range [1, 1000]",
    "-104 <= root.val <= 104",
    "-104 <= subRoot.val <= 104"
  ],
  "testCases": [
    {
      "input": {
        "root": [3, 4, 5, 1, 2],
        "subRoot": [4, 1, 2]
      },
      "output": true,
      "explanation": "The subtree with root 4 has the same structure and values as subRoot."
    },
    {
      "input": {
        "root": [3, 4, 5, 1, 2, null, null, null, null, 0],
        "subRoot": [4, 1, 2]
      },
      "output": false,
      "explanation": "No subtree matches the structure and values of subRoot."
    },
    {
      "input": {
        "root": [1, 1],
        "subRoot": [1]
      },
      "output": true,
      "explanation": "The subtree with root 1 matches subRoot."
    },
    {
      "input": {
        "root": [1, 2, 3],
        "subRoot": [1, 2]
      },
      "output": false,
      "explanation": "No subtree matches the structure of subRoot."
    }
  ],
  "solution": {
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef isSubtree(root, subRoot):\n    # Helper function to check if two trees are identical\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n    \n    # Base case: if subRoot is None, it's always a subtree\n    if not subRoot:\n        return True\n    \n    # Base case: if root is None but subRoot is not, it's not a subtree\n    if not root:\n        return False\n    \n    # Check if current root matches subRoot\n    if isSameTree(root, subRoot):\n        return True\n    \n    # Recursively check left and right subtrees\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\n# Alternative approach using string serialization\ndef isSubtreeSerialization(root, subRoot):\n    # Helper function to serialize a tree\n    def serialize(node):\n        if not node:\n            return 'null'\n        return str(node.val) + ',' + serialize(node.left) + ',' + serialize(node.right)\n    \n    # Serialize both trees\n    root_str = serialize(root)\n    subRoot_str = serialize(subRoot)\n    \n    # Check if subRoot string is a substring of root string\n    return subRoot_str in root_str\n\n# Alternative approach using preorder traversal\ndef isSubtreePreorder(root, subRoot):\n    # Helper function to check if two trees are identical\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n    \n    # Use DFS to find potential matches\n    def dfs(node):\n        if not node:\n            return False\n        \n        # Check if current node matches subRoot\n        if isSameTree(node, subRoot):\n            return True\n        \n        # Recursively check left and right subtrees\n        return dfs(node.left) or dfs(node.right)\n    \n    return dfs(root)\n\n# Alternative approach with early termination\ndef isSubtreeOptimized(root, subRoot):\n    # Helper function to check if two trees are identical\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n    \n    # Use BFS for level-order traversal\n    if not root or not subRoot:\n        return False\n    \n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        \n        # Check if current node matches subRoot\n        if isSameTree(node, subRoot):\n            return True\n        \n        # Add children to queue\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    \n    return False",
    "explanation": "Four approaches are shown:\n\n1. Recursive approach (DFS) - Recommended:\n   - Use a helper function to check if two trees are identical\n   - For each node in root, check if it matches subRoot\n   - Recursively check left and right subtrees\n   - Time complexity: O(n * m) where n and m are the number of nodes\n   - Space complexity: O(max(h1, h2)) where h1 and h2 are the heights\n\n2. String serialization approach:\n   - Serialize both trees to strings\n   - Check if subRoot string is a substring of root string\n   - Time complexity: O(n + m)\n   - Space complexity: O(n + m) for the serialized strings\n\n3. Preorder traversal approach:\n   - Use DFS to traverse the root tree\n   - For each node, check if it matches subRoot\n   - Time complexity: O(n * m)\n   - Space complexity: O(max(h1, h2))\n\n4. BFS approach:\n   - Use level-order traversal\n   - Check each node for a match with subRoot\n   - Time complexity: O(n * m)\n   - Space complexity: O(w) where w is the maximum width\n\nKey insight: A subtree must have identical structure and values as the subRoot tree.\n\nExample with root=[3,4,5,1,2] and subRoot=[4,1,2]:\n- Check root=3: doesn't match\n- Check root.left=4: matches subRoot structure and values\n- Result: True\n\nThe recursive approach is the most intuitive and commonly used solution for this problem."
  }
}

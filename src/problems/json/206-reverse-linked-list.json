{
  "id": 206,
  "title": "Reverse Linked List",
  "list": ["grind75"],
  "category": "Linked List",
  "topics": ["Linked List", "Recursion"],
  "difficulty": "Easy",
  "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
  "constraints": [
    "The number of nodes in the list is the range [0, 5000]",
    "-5000 <= Node.val <= 5000"
  ],
  "testCases": [
    {
      "input": {
        "head": [1, 2, 3, 4, 5]
      },
      "output": [5, 4, 3, 2, 1],
      "explanation": "The linked list is reversed: 1->2->3->4->5 becomes 5->4->3->2->1."
    },
    {
      "input": {
        "head": [1, 2]
      },
      "output": [2, 1],
      "explanation": "The linked list is reversed: 1->2 becomes 2->1."
    },
    {
      "input": {
        "head": []
      },
      "output": [],
      "explanation": "An empty linked list remains empty."
    },
    {
      "input": {
        "head": [1]
      },
      "output": [1],
      "explanation": "A single node linked list remains the same."
    }
  ],
  "solution": {
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\ndef reverse_list(head):\n    # Iterative approach\n    prev = None\n    current = head\n    \n    while current:\n        # Store the next node\n        next_node = current.next\n        \n        # Reverse the link\n        current.next = prev\n        \n        # Move prev and current one step forward\n        prev = current\n        current = next_node\n    \n    return prev\n\n# Alternative recursive approach\ndef reverse_list_recursive(head):\n    # Base case: if head is None or head.next is None\n    if not head or not head.next:\n        return head\n    \n    # Recursively reverse the rest of the list\n    new_head = reverse_list_recursive(head.next)\n    \n    # Reverse the link between current node and next node\n    head.next.next = head\n    head.next = None\n    \n    return new_head\n\n# Alternative iterative approach with dummy node\ndef reverse_list_dummy(head):\n    if not head:\n        return None\n    \n    # Create a dummy node\n    dummy = ListNode(0)\n    dummy.next = head\n    \n    # Get the first and second nodes\n    first = dummy.next\n    second = first.next\n    \n    # Reverse the list\n    while second:\n        first.next = second.next\n        second.next = dummy.next\n        dummy.next = second\n        second = first.next\n    \n    return dummy.next\n\n# Alternative approach using stack\ndef reverse_list_stack(head):\n    if not head:\n        return None\n    \n    # Push all nodes to stack\n    stack = []\n    current = head\n    while current:\n        stack.append(current)\n        current = current.next\n    \n    # Pop nodes and reverse links\n    new_head = stack.pop()\n    current = new_head\n    \n    while stack:\n        current.next = stack.pop()\n        current = current.next\n    \n    # Set the last node's next to None\n    current.next = None\n    \n    return new_head",
    "explanation": "Four approaches are shown:\n\n1. Iterative approach (recommended):\n   - Use three pointers: prev, current, and next_node\n   - Iterate through the list, reversing each link\n   - Time complexity: O(n) where n is the number of nodes\n   - Space complexity: O(1) - only uses a constant amount of extra space\n\n2. Recursive approach:\n   - Use recursion to reverse the rest of the list\n   - Base case: when head is None or head.next is None\n   - Reverse the link between current node and next node\n   - Time complexity: O(n)\n   - Space complexity: O(n) due to recursion stack\n\n3. Dummy node approach:\n   - Use a dummy node to simplify the reversal process\n   - Keep track of first and second nodes\n   - Move second node to the front of the list\n   - Time complexity: O(n)\n   - Space complexity: O(1)\n\n4. Stack approach:\n   - Push all nodes to a stack\n   - Pop nodes and reverse the links\n   - Less efficient but demonstrates a different approach\n   - Time complexity: O(n)\n   - Space complexity: O(n) for the stack\n\nThe iterative approach is the most efficient and commonly used solution for this problem."
  }
}

{
  "id": 230,
  "title": "Kth Smallest Element in a BST",
  "list": ["grind75", "neetcode150"],
  "category": "Trees",
  "difficulty": "Medium",
  "description": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
  "constraints": [
    "The number of nodes in the tree is n",
    "1 <= k <= n <= 104",
    "0 <= Node.val <= 104"
  ],
  "testCases": [
    {
      "input": {
        "root": [3, 1, 4, null, 2],
        "k": 1
      },
      "output": 1,
      "explanation": "The 1st smallest element is 1."
    },
    {
      "input": {
        "root": [5, 3, 6, 2, 4, null, null, 1],
        "k": 3
      },
      "output": 3,
      "explanation": "The 3rd smallest element is 3."
    },
    {
      "input": {
        "root": [2, 1, 3],
        "k": 2
      },
      "output": 2,
      "explanation": "The 2nd smallest element is 2."
    }
  ],
  "solution": {
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kthSmallest(root: TreeNode, k: int) -> int:\n    def inorder_traversal(node: TreeNode) -> None:\n        nonlocal count, result\n        if not node:\n            return\n        \n        # Traverse left subtree\n        inorder_traversal(node.left)\n        \n        # Process current node\n        count += 1\n        if count == k:\n            result = node.val\n            return\n        \n        # Traverse right subtree\n        inorder_traversal(node.right)\n    \n    count = 0\n    result = None\n    inorder_traversal(root)\n    return result",
    "explanation": "This solution uses inorder traversal to find the kth smallest element:\n1. We use inorder traversal which visits nodes in ascending order in a BST\n2. We keep track of the count of nodes visited\n3. When count equals k, we've found the kth smallest element\n4. We can stop early once we find the kth element\n\nKey insight: Inorder traversal of a BST visits nodes in sorted order (left -> root -> right)\n\nExample: root = [3, 1, 4, null, 2], k = 1\n- Inorder traversal: 1 -> 2 -> 3 -> 4\n- Count = 1: node.val = 1 â†’ this is the 1st smallest element\n- Result: 1\n\nAlternative approach using iterative inorder traversal:\n- Use a stack to simulate recursion\n- Push all left children to stack\n- Pop and process nodes, then push right child\n- Stop when count reaches k\n\nThe time complexity is O(k) in the worst case (when k = n). The space complexity is O(h) where h is the height of the tree for the recursion stack."
  }
}

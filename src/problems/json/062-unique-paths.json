{
  "id": 62,
  "title": "Unique Paths",
  "list": ["grind75"],
  "category": "2-D DP",
  "difficulty": "Medium",
  "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.",
  "constraints": ["1 <= m, n <= 100"],
  "testCases": [
    {
      "input": {
        "m": 3,
        "n": 7
      },
      "output": 28,
      "explanation": "There are 28 unique paths from (0,0) to (2,6)."
    },
    {
      "input": {
        "m": 3,
        "n": 2
      },
      "output": 3,
      "explanation": "From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right → Down → Down\n2. Down → Down → Right\n3. Down → Right → Down"
    },
    {
      "input": {
        "m": 7,
        "n": 3
      },
      "output": 28,
      "explanation": "Same as the first example but with m and n swapped."
    }
  ],
  "solution": {
    "code": "def uniquePaths(m: int, n: int) -> int:\n    # Create a 2D DP array\n    dp = [[0] * n for _ in range(m)]\n    \n    # Base case: first row and first column have only 1 path\n    for i in range(m):\n        dp[i][0] = 1\n    for j in range(n):\n        dp[0][j] = 1\n    \n    # Fill the DP array\n    for i in range(1, m):\n        for j in range(1, n):\n            # Paths to current cell = paths from above + paths from left\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]",
    "explanation": "This solution uses dynamic programming:\n1. We create a 2D DP array where dp[i][j] represents the number of unique paths to reach cell (i,j)\n2. Base cases: first row and first column have only 1 path each (can only move right or down)\n3. For each cell (i,j), the number of paths = paths from above (i-1,j) + paths from left (i,j-1)\n4. We fill the DP array row by row, column by column\n5. The answer is dp[m-1][n-1]\n\nExample: m = 3, n = 2\nDP array:\n[1, 1]\n[1, 2]\n[1, 3]\n\n- dp[0][0] = 1 (base case)\n- dp[0][1] = 1 (base case)\n- dp[1][0] = 1 (base case)\n- dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2\n- dp[2][0] = 1 (base case)\n- dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3\n\nAlternative approach using combinatorics:\n- The problem is equivalent to choosing (m-1) down moves out of (m+n-2) total moves\n- Answer = C(m+n-2, m-1) = (m+n-2)! / ((m-1)! * (n-1)!)\n\nThe time complexity is O(m * n) as we fill the entire DP array. The space complexity is O(m * n) for the DP array."
  }
}

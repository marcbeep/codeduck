{
  "id": 102,
  "title": "Binary Tree Level Order Traversal",
  "list": [
    "grind75"
  ],
  "category": "Binary Tree BFS",
  "difficulty": "Medium",
  "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
  "constraints": [
    "The number of nodes in the tree is in the range [0, 2000]",
    "-1000 <= Node.val <= 1000"
  ],
  "testCases": [
    {
      "input": {
        "root": [
          3,
          9,
          20,
          null,
          null,
          15,
          7
        ]
      },
      "output": [
        [
          3
        ],
        [
          9,
          20
        ],
        [
          15,
          7
        ]
      ],
      "explanation": "Level 0: [3], Level 1: [9,20], Level 2: [15,7]"
    },
    {
      "input": {
        "root": [
          1
        ]
      },
      "output": [
        [
          1
        ]
      ],
      "explanation": "Single node tree."
    },
    {
      "input": {
        "root": []
      },
      "output": [],
      "explanation": "Empty tree."
    }
  ],
  "solution": {
    "code": "from collections import deque\nfrom typing import Optional, List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef level_order(root: Optional[TreeNode]) -> List[List[int]]:\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        # Process all nodes at current level\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            \n            # Add children to queue for next level\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result",
    "explanation": "This solution uses BFS (Breadth-First Search) with O(n) time complexity:\n1. We use a queue to implement BFS traversal\n2. We process nodes level by level by tracking the queue size at each level\n3. For each level, we process all nodes in the queue and add their children\n4. We collect all values at the current level before moving to the next\n5. We continue until the queue is empty\n\nThe time complexity is O(n) as we visit each node exactly once. The space complexity is O(w) where w is the maximum width of the tree (number of nodes at the widest level).\n\nKey insights:\n- BFS naturally gives us level-order traversal\n- We need to track level boundaries to group nodes by level\n- The queue size at the start of each level tells us how many nodes to process\n- We add children to the queue for processing in the next level\n\nAlternative approach: We could also use DFS with level tracking, but BFS is more natural for level-order traversal."
  }
}

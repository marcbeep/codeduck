{
  "id": 100,
  "title": "Same Tree",
  "list": ["neetcode150"],
  "category": "Trees",
  "difficulty": "Easy",
  "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
  "constraints": [
    "The number of nodes in both trees is in the range [0, 100]",
    "-104 <= Node.val <= 104"
  ],
  "testCases": [
    {
      "input": {
        "p": [1, 2, 3],
        "q": [1, 2, 3]
      },
      "output": true,
      "explanation": "Both trees have the same structure and values."
    },
    {
      "input": {
        "p": [1, 2],
        "q": [1, null, 2]
      },
      "output": false,
      "explanation": "Trees have different structures."
    },
    {
      "input": {
        "p": [1, 2, 1],
        "q": [1, 1, 2]
      },
      "output": false,
      "explanation": "Trees have same structure but different values."
    },
    {
      "input": {
        "p": [],
        "q": []
      },
      "output": true,
      "explanation": "Both trees are empty."
    }
  ],
  "solution": {
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef isSameTree(p, q):\n    # Base case: if both nodes are None, they are the same\n    if not p and not q:\n        return True\n    \n    # If one node is None and the other is not, they are different\n    if not p or not q:\n        return False\n    \n    # Check if current nodes have the same value\n    if p.val != q.val:\n        return False\n    \n    # Recursively check left and right subtrees\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n# Alternative iterative approach using BFS\ndef isSameTreeIterative(p, q):\n    # Use a queue to process nodes level by level\n    queue = [(p, q)]\n    \n    while queue:\n        node1, node2 = queue.pop(0)\n        \n        # If both nodes are None, continue\n        if not node1 and not node2:\n            continue\n        \n        # If one node is None and the other is not, return False\n        if not node1 or not node2:\n            return False\n        \n        # If values are different, return False\n        if node1.val != node2.val:\n            return False\n        \n        # Add children to queue\n        queue.append((node1.left, node2.left))\n        queue.append((node1.right, node2.right))\n    \n    return True\n\n# Alternative approach using DFS with stack\ndef isSameTreeDFS(p, q):\n    # Use a stack for DFS\n    stack = [(p, q)]\n    \n    while stack:\n        node1, node2 = stack.pop()\n        \n        # If both nodes are None, continue\n        if not node1 and not node2:\n            continue\n        \n        # If one node is None and the other is not, return False\n        if not node1 or not node2:\n            return False\n        \n        # If values are different, return False\n        if node1.val != node2.val:\n            return False\n        \n        # Add children to stack (right first for DFS)\n        stack.append((node1.right, node2.right))\n        stack.append((node1.left, node2.left))\n    \n    return True",
    "explanation": "Three approaches are shown:\n\n1. Recursive approach (DFS) - Recommended:\n   - Base case: if both nodes are None, return True\n   - If one node is None and the other is not, return False\n   - Check if current nodes have the same value\n   - Recursively check left and right subtrees\n   - Time complexity: O(min(n, m)) where n and m are the number of nodes\n   - Space complexity: O(min(h1, h2)) where h1 and h2 are the heights of the trees\n\n2. Iterative approach (BFS):\n   - Use a queue to process nodes level by level\n   - Compare nodes at the same level\n   - Add children to queue for processing\n   - Time complexity: O(min(n, m))\n   - Space complexity: O(min(w1, w2)) where w1 and w2 are the maximum widths\n\n3. Iterative approach (DFS with stack):\n   - Use a stack for depth-first traversal\n   - Compare nodes as we traverse\n   - Add children to stack for processing\n   - Time complexity: O(min(n, m))\n   - Space complexity: O(min(h1, h2))\n\nKey insight: Two trees are the same if they have identical structure and values at every node.\n\nExample with [1,2,3] and [1,2,3]:\n- Root: 1 == 1 ✓\n- Left child: 2 == 2 ✓\n- Right child: 3 == 3 ✓\n- Result: True\n\nThe recursive approach is the most elegant and commonly used solution for this problem."
  }
}

{
  "id": 143,
  "title": "Reorder List",
  "list": ["neetcode150"],
  "category": "Linked List",
  "difficulty": "Medium",
  "description": "You are given the head of a singly linked-list. The list can be represented as:\n\nL0 → L1 → … → Ln - 1 → Ln\nReorder the list to be on the following form:\n\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
  "constraints": [
    "The number of nodes in the list is in the range [1, 5 * 104]",
    "1 <= Node.val <= 1000"
  ],
  "testCases": [
    {
      "input": {
        "head": [1, 2, 3, 4]
      },
      "output": [1, 4, 2, 3],
      "explanation": "The list is reordered: L0→L1→L2→L3 becomes L0→L3→L1→L2."
    },
    {
      "input": {
        "head": [1, 2, 3, 4, 5]
      },
      "output": [1, 5, 2, 4, 3],
      "explanation": "The list is reordered: L0→L1→L2→L3→L4 becomes L0→L4→L1→L3→L2."
    },
    {
      "input": {
        "head": [1]
      },
      "output": [1],
      "explanation": "Single node list remains unchanged."
    },
    {
      "input": {
        "head": [1, 2]
      },
      "output": [1, 2],
      "explanation": "Two node list remains unchanged."
    }
  ],
  "solution": {
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\ndef reorderList(head):\n    if not head or not head.next:\n        return head\n    \n    # Step 1: Find the middle of the list\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Step 2: Reverse the second half\n    second = slow.next\n    slow.next = None  # Split the list\n    prev = None\n    current = second\n    \n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    \n    # Step 3: Merge the two halves\n    first = head\n    second = prev\n    \n    while second:\n        temp1 = first.next\n        temp2 = second.next\n        \n        first.next = second\n        second.next = temp1\n        \n        first = temp1\n        second = temp2\n    \n    return head\n\n# Alternative approach using stack\ndef reorderListStack(head):\n    if not head or not head.next:\n        return head\n    \n    # Find the middle\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Push second half to stack\n    stack = []\n    current = slow.next\n    slow.next = None\n    \n    while current:\n        stack.append(current)\n        current = current.next\n    \n    # Merge by popping from stack\n    current = head\n    while stack:\n        node = stack.pop()\n        temp = current.next\n        current.next = node\n        node.next = temp\n        current = temp\n    \n    return head",
    "explanation": "This solution uses a three-step approach:\n\n1. Find the middle of the list using fast and slow pointers:\n   - Fast pointer moves 2 steps, slow pointer moves 1 step\n   - When fast reaches the end, slow is at the middle\n   - Split the list at the middle\n\n2. Reverse the second half:\n   - Use three pointers (prev, current, next) to reverse the second half\n   - This gives us the second half in reverse order\n\n3. Merge the two halves:\n   - Interleave nodes from first half and reversed second half\n   - Use temporary variables to preserve next pointers\n\nExample with [1,2,3,4,5]:\n- Step 1: Find middle at 3, split into [1,2,3] and [4,5]\n- Step 2: Reverse second half: [4,5] becomes [5,4]\n- Step 3: Merge: 1→5→2→4→3\n\nTime complexity: O(n) where n is the number of nodes\nSpace complexity: O(1) for the three-step approach, O(n) for the stack approach\n\nThe three-step approach is more efficient as it uses constant extra space."
  }
}

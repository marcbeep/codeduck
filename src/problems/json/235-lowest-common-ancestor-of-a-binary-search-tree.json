{
  "id": 235,
  "title": "Lowest Common Ancestor of a Binary Search Tree",
  "list": ["grind75", "neetcode150"],
  "category": "Trees",
  "difficulty": "Medium",
  "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\"",
  "constraints": [
    "The number of nodes in the tree is in the range [2, 105]",
    "-109 <= Node.val <= 109",
    "All Node.val are unique",
    "p != q",
    "p and q will exist in the BST"
  ],
  "testCases": [
    {
      "input": {
        "root": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p": 2,
        "q": 8
      },
      "output": 6,
      "explanation": "The LCA of nodes 2 and 8 is 6."
    },
    {
      "input": {
        "root": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p": 2,
        "q": 4
      },
      "output": 2,
      "explanation": "The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself."
    },
    {
      "input": {
        "root": [2, 1],
        "p": 2,
        "q": 1
      },
      "output": 2,
      "explanation": "The LCA of nodes 2 and 1 is 2."
    }
  ],
  "solution": {
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\ndef lowest_common_ancestor(root, p, q):\n    # If both p and q are less than root, LCA is in left subtree\n    if p.val < root.val and q.val < root.val:\n        return lowest_common_ancestor(root.left, p, q)\n    \n    # If both p and q are greater than root, LCA is in right subtree\n    if p.val > root.val and q.val > root.val:\n        return lowest_common_ancestor(root.right, p, q)\n    \n    # If one is less and one is greater, or one equals root, root is LCA\n    return root",
    "explanation": "This solution uses BST property for efficient LCA finding:\n- If both p and q are less than root, search left subtree\n- If both p and q are greater than root, search right subtree\n- Otherwise, root is the LCA\n- Time complexity: O(h) where h is the height of the tree\n- Space complexity: O(h) due to recursion stack"
  }
}

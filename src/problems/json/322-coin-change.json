{
  "id": 322,
  "title": "Coin Change",
  "list": [
    "grind75"
  ],
  "category": "1D DP",
  "difficulty": "Medium",
  "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
  "constraints": [
    "1 <= coins.length <= 12",
    "1 <= coins[i] <= 231 - 1",
    "0 <= amount <= 104"
  ],
  "testCases": [
    {
      "input": {
        "coins": [
          1,
          2,
          5
        ],
        "amount": 11
      },
      "output": 3,
      "explanation": "11 = 5 + 5 + 1"
    },
    {
      "input": {
        "coins": [
          2
        ],
        "amount": 3
      },
      "output": -1,
      "explanation": "It is impossible to make 3 with only coin of denomination 2."
    },
    {
      "input": {
        "coins": [
          1
        ],
        "amount": 0
      },
      "output": 0,
      "explanation": "Amount 0 can be made with 0 coins."
    }
  ],
  "solution": {
    "code": "def coin_change(coins: list[int], amount: int) -> int:\n    # Initialize DP array with infinity\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # Base case: 0 amount needs 0 coins\n    \n    # Fill DP array\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1",
    "explanation": "This solution uses dynamic programming with O(amount * len(coins)) time complexity:\n1. We create a DP array where dp[i] represents the minimum coins needed for amount i\n2. We initialize dp[0] = 0 (base case) and all others to infinity\n3. For each amount from 1 to target, we try each coin denomination\n4. If a coin can be used (coin <= current amount), we update dp[i] with the minimum\n5. The final answer is dp[amount] if it's not infinity, otherwise -1\n\nThe time complexity is O(amount * len(coins)) as we fill the DP array. The space complexity is O(amount) for the DP array.\n\nKey insights:\n- This is a classic unbounded knapsack problem\n- We can use each coin multiple times (infinite supply)\n- The optimal substructure: min coins for amount i = min(min coins for amount i-coin + 1)\n- We use infinity to represent impossible amounts\n- The DP array naturally handles the minimum calculation\n\nAlternative approach: We could also use BFS where each state represents a remaining amount, but DP is more efficient for this problem."
  }
}

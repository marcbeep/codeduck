{
  "id": 743,
  "title": "Network Delay Time",
  "list": ["neetcode150"],
  "category": "Advanced Graphs",
  "difficulty": "Medium",
  "description": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.",
  "constraints": [
    "1 <= k <= n <= 100",
    "1 <= times.length <= 6000",
    "times[i].length == 3",
    "1 <= ui, vi <= n",
    "ui != vi",
    "0 <= wi <= 100",
    "All the pairs (ui, vi) are unique. (i.e., no multiple edges.)"
  ],
  "testCases": [
    {
      "input": {
        "times": [
          [2, 1, 1],
          [2, 3, 1],
          [3, 4, 1]
        ],
        "n": 4,
        "k": 2
      },
      "output": 2,
      "explanation": "Signal starts at node 2. It takes 1 time unit to reach node 1, and 2 time units to reach node 4."
    },
    {
      "input": {
        "times": [[1, 2, 1]],
        "n": 2,
        "k": 1
      },
      "output": 1,
      "explanation": "Signal starts at node 1 and reaches node 2 in 1 time unit."
    },
    {
      "input": {
        "times": [[1, 2, 1]],
        "n": 2,
        "k": 2
      },
      "output": -1,
      "explanation": "Signal starts at node 2 but cannot reach node 1, so it's impossible for all nodes to receive the signal."
    }
  ],
  "solution": {
    "code": "import heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times: list[list[int]], n: int, k: int) -> int:\n # Build adjacency list\n graph = defaultdict(list)\n for u, v, w in times:\n graph[u].append((v, w))\n \n # Dijkstra's algorithm\n distances = {i: float('inf') for i in range(1, n + 1)}\n distances[k] = 0\n \n # Priority queue: (distance, node)\n pq = [(0, k)]\n \n while pq:\n current_dist, current_node = heapq.heappop(pq)\n \n # Skip if we already found a shorter path\n if current_dist > distances[current_node]:\n continue\n \n # Explore neighbors\n for neighbor, weight in graph[current_node]:\n distance = current_dist + weight\n \n if distance < distances[neighbor]:\n distances[neighbor] = distance\n heapq.heappush(pq, (distance, neighbor))\n \n # Find maximum distance\n max_distance = max(distances.values())\n \n return max_distance if max_distance != float('inf') else -1",
    "explanation": "This solution uses Dijkstra's algorithm to find the shortest path from the source node to all other nodes:\n1. Build an adjacency list representation of the graph\n2. Use a priority queue to always process the node with the smallest current distance\n3. For each node, explore all its neighbors and update distances if a shorter path is found\n4. Return the maximum distance, which represents the time for all nodes to receive the signal\n\nTime complexity: O((V + E) log V) where V is the number of nodes and E is the number of edges\nSpace complexity: O(V + E)"
  }
}

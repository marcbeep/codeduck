{
  "id": 67,
  "title": "Add Binary",
  "list": ["grind75"],
  "category": "Array/String",
  "topics": ["String", "Math", "Bit Manipulation", "Simulation"],
  "difficulty": "Easy",
  "description": "Given two binary strings a and b, return their sum as a binary string.",
  "constraints": [
    "1 <= a.length, b.length <= 104",
    "a and b consist only of '0' or '1' characters",
    "Each string does not contain leading zeros except for the zero itself"
  ],
  "testCases": [
    {
      "input": {
        "a": "11",
        "b": "1"
      },
      "output": "100",
      "explanation": "11 + 1 = 100 in binary."
    },
    {
      "input": {
        "a": "1010",
        "b": "1011"
      },
      "output": "10101",
      "explanation": "1010 + 1011 = 10101 in binary."
    },
    {
      "input": {
        "a": "0",
        "b": "0"
      },
      "output": "0",
      "explanation": "0 + 0 = 0 in binary."
    },
    {
      "input": {
        "a": "1111",
        "b": "1111"
      },
      "output": "11110",
      "explanation": "1111 + 1111 = 11110 in binary."
    }
  ],
  "solution": {
    "code": "def add_binary(a: str, b: str) -> str:\n    # Convert binary strings to integers, add, then convert back\n    # This approach is simple but may not work for very large numbers\n    \n    # Convert binary strings to integers\n    a_int = int(a, 2)\n    b_int = int(b, 2)\n    \n    # Add the integers\n    sum_int = a_int + b_int\n    \n    # Convert back to binary string\n    return bin(sum_int)[2:]\n\n# Alternative approach using bit-by-bit addition\ndef add_binary_bit_by_bit(a: str, b: str) -> str:\n    # Make both strings the same length by padding with zeros\n    max_len = max(len(a), len(b))\n    a = a.zfill(max_len)\n    b = b.zfill(max_len)\n    \n    result = []\n    carry = 0\n    \n    # Add from right to left\n    for i in range(max_len - 1, -1, -1):\n        # Get the current digits\n        a_digit = int(a[i])\n        b_digit = int(b[i])\n        \n        # Calculate sum and carry\n        current_sum = a_digit + b_digit + carry\n        result.append(str(current_sum % 2))\n        carry = current_sum // 2\n    \n    # If there's a carry at the end, add it\n    if carry:\n        result.append('1')\n    \n    # Reverse and join\n    return ''.join(result[::-1])\n\n# Alternative approach using XOR and carry\ndef add_binary_xor(a: str, b: str) -> str:\n    # Convert to integers\n    x, y = int(a, 2), int(b, 2)\n    \n    while y:\n        # Calculate carry\n        carry = x & y\n        # Calculate sum without carry\n        x = x ^ y\n        # Shift carry left by 1\n        y = carry << 1\n    \n    return bin(x)[2:]\n\n# Alternative approach using string manipulation\ndef add_binary_string_manipulation(a: str, b: str) -> str:\n    # Reverse both strings for easier processing\n    a, b = a[::-1], b[::-1]\n    \n    result = []\n    carry = 0\n    i = 0\n    \n    # Process both strings\n    while i < len(a) or i < len(b) or carry:\n        # Get digits (0 if index out of range)\n        a_digit = int(a[i]) if i < len(a) else 0\n        b_digit = int(b[i]) if i < len(b) else 0\n        \n        # Calculate sum\n        total = a_digit + b_digit + carry\n        result.append(str(total % 2))\n        carry = total // 2\n        i += 1\n    \n    # Reverse and join\n    return ''.join(result[::-1])",
    "explanation": "Four approaches are shown:\n\n1. Built-in conversion approach (recommended for small numbers):\n   - Convert binary strings to integers using int(s, 2)\n   - Add the integers\n   - Convert back to binary using bin()\n   - Time complexity: O(n) where n is the length of the longer string\n   - Space complexity: O(n)\n   - Note: May not work for very large numbers due to integer overflow\n\n2. Bit-by-bit addition approach:\n   - Pad shorter string with leading zeros\n   - Add digits from right to left\n   - Handle carry properly\n   - Time complexity: O(max(len(a), len(b)))\n   - Space complexity: O(max(len(a), len(b)))\n\n3. XOR and carry approach:\n   - Use bitwise operations to simulate addition\n   - XOR gives sum without carry\n   - AND gives carry\n   - Shift carry left and repeat\n   - Time complexity: O(log(max(a, b)))\n   - Space complexity: O(1)\n\n4. String manipulation approach:\n   - Reverse strings for easier processing\n   - Process both strings simultaneously\n   - Handle carry and different lengths\n   - Time complexity: O(max(len(a), len(b)))\n   - Space complexity: O(max(len(a), len(b)))\n\nThe bit-by-bit approach is the most robust and works for all input sizes."
  }
}
